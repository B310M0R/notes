# Binary Exploitation

## Writing first program in C

```c
#include <stdio.h>
int main(int argc, char *argv[]) {
    if(argc==2) {
        printf("Knock, knock, %s\n", argv[1]);
        return 0;
    } else {
        fprintf(stderr, "Usage: %s <name>\n", argv[0]);
        return 1;
    }
}
```

main() is always main function in C and here program starts its execution  
In this example first argument (argv[0]) is a program name and the second - user's value

### Compiling

```bash
gcc <app.c> -o app -Wall
./app Neo
\> Knock, knock, Neo
```

-o stands for out file, -Wall stands for enabling all warnings  

### "Real-life" use of compiled code

Edit .bashrc and add to the end next line

```bash
/path/to/app $USER
```

## How CPU works

RIP (Instruction Pointer) = PC (Program Counter) = EIP = IP  
RIP keeps number of a line in memory that must be executed next

```assembler
mov eax, 0x5            | eax = 5
add eax, 0x3            | eax = 8
mov ebx, 0x8            | ebx = 8
sub eax, ebx            | eax - ebx (eax = 0)
```

What doesn't fit in registers, lives in memory. We can put values in memory and take them from it with `mov` operation

```assembler
mov eax, [14]           | puts into eax register value of 14th line of memory. 14 here works like an array pointer and array is a computer's memory
```

esp is a registry that points at the last stack address  
CPU uses special instructions to jump from line ti line (jumps, branches, calls)

```assembler
jmp 5       | goes to memory address 5. It equals to mov eip, 5 
```

Jump is unconditional instruction, but assembler also has conditional instructions such as branch if equal or jum if equal  
Also assembler has special registers values called flags, for example zero flag  
If result of instructions is equal to zero, zero flag becomes 1  
And there are instructions such as `jump if zero (jz)`, `jump if equal(je)` or `branch if zero (beq)`
`call` instruction executes some function and returns to a previous address from which it was called

## Cracking first program

```bash
gdb <app>
> set disassembly-flavor intel        #intel syntax
> disas main
```

Check call, cmp and jne instructions and their addresses  
It will be a good idea to print on separate paper disas code and write logical blocks on this paper or use IDA/radare or another disas tool  

Set breakpoint at the main

```bash
> break *main
> info registers (check rip)
> si (one step forward)
> info registers (check rip again) 
> ni (like si, but steps only through main functionality)
```

To pass arguments into the program just type `run <arg1> <arg2> ...`  
After errors caused by some check (e.g. cmp or test instructions), set breakpoints before this instructions to test them  
If we have more then 1 break, run `continue` in place of `ni` or `si` in order to run program normally until next breakpoint  
If you see `eax` compatision or tests, you can try to set it to 0  
Also if we see `cmp` instruction, we can set break before it, check its registers (especially rsi) and run `x/s 0x<rsi>` to see what is checked  

```bash
> set $eax=0
```

## Tools and techiques for binary reverse

```bash
file <bin>
hexdum <bin>
strings <bin>
objdump -d <bin>
strace <bin> (it will show syscalls to linux kernel)
ltrace <bin> (it checks function libraries dependencies)
```

Tools:

* Hopper disassembler  
* radare2
* IDA

### radare 2

```bash
r2 <bin>
> aaa (auto analyze and name funcs)
> afl (print functions)
> ? (help)
> s <func_name> (go to func)
> pdf (print disas of func)
> VV (visual mode of control graph)
r2 -d <bin> (debug like gdb)
> db <address> (break at addr)
: - enter type mode
: dc - run program
s or shift+s - like si or ni in gdb 
```

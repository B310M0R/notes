# Binary Exploitation

## Writing first program in C

```c
#include <stdio.h>
int main(int argc, char *argv[]) {
    if(argc==2) {
        printf("Knock, knock, %s\n", argv[1]);
        return 0;
    } else {
        fprintf(stderr, "Usage: %s <name>\n", argv[0]);
        return 1;
    }
}
```

main() is always main function in C and here program starts its execution  
In this example first argument (argv[0]) is a program name and the second - user's value

### Compiling

```bash
gcc <app.c> -o app -Wall
./app Neo
\> Knock, knock, Neo
```
-o stands for out file, -Wall stands for enabling all warnings  

### "Real-life" use of compiled code
Edit .bashrc and add to the end next line
```
/path/to/app $USER
```

## How CPU works
RIP (Instruction Pointer) = PC (Program Counter) = EIP = IP  
RIP keeps number of a line in memory that must be executed next
```
mov eax, 0x5            | eax = 5
add eax, 0x3            | eax = 8
mov ebx, 0x8            | ebx = 8
sub eax, ebx            | eax - ebx (eax = 0)
```
What doesn't fit in registers, lives in memory. We can put values in memory and take them from it with `mov` operation
```
mov eax, [14]           | puts into eax register value of 14th line of memory. 14 here works like an array pointer and array is a computer's memory
```
esp is a registry that points at the last stack address  
CPU uses special instructions to jump from line ti line (jumps, branches, calls)  
```
jmp 5       | goes to memory address 5. It equals to mov eip, 5 
```
Jump is unconditional instruction, but assembler also has conditional instructions such as branch if equal or jum if equal  
Also assembler has special registers values called flags, for example zero flag  
If result of instructions is equal to zero, zero flag becomes 1  
And there are instructions such as `jump if zero (jz)`, `jump if equal(je)` or `branch if zero (beq)`
`call` instruction executes some function and returns to a previous address from which it was called
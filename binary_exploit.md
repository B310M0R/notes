# Binary Exploitation

## Writing first program in C

```c
#include <stdio.h>
int main(int argc, char *argv[]) {
    if(argc==2) {
        printf("Knock, knock, %s\n", argv[1]);
        return 0;
    } else {
        fprintf(stderr, "Usage: %s <name>\n", argv[0]);
        return 1;
    }
}
```

main() is always main function in C and here program starts its execution  
In this example first argument (argv[0]) is a program name and the second - user's value

### Compiling

```bash
gcc <app.c> -o app -Wall
./app Neo
\> Knock, knock, Neo
```

-o stands for out file, -Wall stands for enabling all warnings  

### "Real-life" use of compiled code

Edit .bashrc and add to the end next line

```bash
/path/to/app $USER
```

## How CPU works

RIP (Instruction Pointer) = PC (Program Counter) = EIP = IP  
RIP keeps number of a line in memory that must be executed next

```assembler
mov eax, 0x5            | eax = 5
add eax, 0x3            | eax = 8
mov ebx, 0x8            | ebx = 8
sub eax, ebx            | eax - ebx (eax = 0)
```

What doesn't fit in registers, lives in memory. We can put values in memory and take them from it with `mov` operation

```assembler
mov eax, [14]           | puts into eax register value of 14th line of memory. 14 here works like an array pointer and array is a computer's memory
```

esp is a registry that points at the last stack address  
CPU uses special instructions to jump from line ti line (jumps, branches, calls)

```assembler
jmp 5       | goes to memory address 5. It equals to mov eip, 5 
```

Jump is unconditional instruction, but assembler also has conditional instructions such as branch if equal or jum if equal  
Also assembler has special registers values called flags, for example zero flag  
If result of instructions is equal to zero, zero flag becomes 1  
And there are instructions such as `jump if zero (jz)`, `jump if equal(je)` or `branch if zero (beq)`
`call` instruction executes some function and returns to a previous address from which it was called

## Cracking first program

```bash
gdb <app>
> set disassembly-flavor intel        #intel syntax
> disas main
```

Check call, cmp and jne instructions and their addresses  
It will be a good idea to print on separate paper disas code and write logical blocks on this paper or use IDA/radare or another disas tool  

Set breakpoint at the main

```bash
> break *main
> info registers (check rip)
> si (one step forward)
> info registers (check rip again) 
> ni (like si, but steps only through main functionality)
```

To pass arguments into the program just type `run <arg1> <arg2> ...`  
After errors caused by some check (e.g. cmp or test instructions), set breakpoints before this instructions to test them  
If we have more then 1 break, run `continue` in place of `ni` or `si` in order to run program normally until next breakpoint  
If you see `eax` compatision or tests, you can try to set it to 0  
Also if we see `cmp` instruction, we can set break before it, check its registers (especially rsi) and run `x/s 0x<rsi>` to see what is checked  

```bash
> set $eax=0
```

## Tools and techiques for binary reverse

```bash
file <bin>
hexdum <bin>
strings <bin>
objdump -d <bin>
strace <bin> (it will show syscalls to linux kernel)
ltrace <bin> (it checks function libraries dependencies)
```

Tools:

* Hopper disassembler  
* radare2
* IDA

### radare 2

```bash
r2 <bin>
> aaa (auto analyze and name funcs)
> afl (print functions)
> ? (help)
> s <func_name> (go to func)
> pdf (print disas of func)
> VV (visual mode of control graph)
r2 -d <bin> (debug like gdb)
> db <address> (break at addr)
: - enter type mode
: dc - run program
s or shift+s - like si or ni in gdb 
dr - show registers
```

## Key validation with Algorithm and creating a Keygen
[Tasks are here!](https://github.com/LiveOverflow/liveoverflow_youtube/tree/master)
0x07_0x08_uncrackable_crackme  
To simply bypass license check, we can find compare instruction, set breakpoint before it and then manually set rip to needed next instruction  
More complex decision is to write keygen  
When analyzing the program, we see branches and loop which has last instruction of incrementing some variable by 1  
We can rename radare-named variable into smth own with `>afvn <variable_name> <our_variable name>`

```bash
r2 bin
> aaa
> afl
> s sym.main
> VV
# First main function checks if we provide license key and jumps to next checks if false:
# cmp dword[rbp - 0x24], 2         | simply checks if argv == 2 (bin name and 1 arg(key))
# jne 0x400663                     | jumps somewhere if we don't provide key
```

If we continue (when we provide a key):

```assembler
mov dword [rbp - 0x18], 0           | we set some variable (offset - 18) to 0
mov dword [rbp-local_2_4], 0        | and more one address (offset - <some number>) equals 0 
# Here variables are calculated by register rbp (Base Pointer)
```

Next we see a loop with incrementation at the end of true condition

```assembler
add dword [rbp-local_2_4], 1        | here is the variable that was set to 0 at previous block (rbp-local_2_4)
# rename variable to i: :avfn local_2_4 i
```

Before loop starts, we have strlen function call and cmp instruction. Then it follows the next block and enters the loop or leave:

```assembler
mov rax, qword [rbp-local_6]        | loads some var into rax
add rax, 8
mov rdx, qword [rax]
mov rdi, rax
call sym.imp.strlen
cmp rbx, rax
jb 0x400604                         | jump into loop address
```

### Loop

```assembler
mov rax, qword [rbp-local_6]        | loads some variable into rax (rbp-local_6). This variable and next two lines appeared before in previous block (loop entrance)
add rax, 8                          | adds 8 to a loaded value. Usually that means that a value loaded is an address (because +8 to address equals to +1 in      decimal. Memory is divided into 8-byte chunks. Adding 8 to an address will give us next value inside the memory array which is next character of key string)
mov rdx, qword [rax]                | so now rdx has address of rax + 8. This simply moves the pointer to our argument (key)     
mov eax, dword[rbp-i]               | eax now contains i (local_2_4) which is counter of the loop     
```